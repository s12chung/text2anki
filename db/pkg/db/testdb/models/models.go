// Code generated by testdb.GenerateModelsCode(). DO NOT EDIT.
//
// Package models contains the models used by testdb
package models

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path"
	"runtime"

	"github.com/s12chung/text2anki/db/pkg/db"
)

var callerPath string

func init() {
	_, callerFilePath, _, ok := runtime.Caller(0)
	if !ok {
		fmt.Println("runtime.Caller not ok for Seed()")
		os.Exit(-1)
	}
	callerPath = path.Dir(callerFilePath)
}

var seedMap = map[string]func() error{
	"Terms":             SeedTerms,
	"SourceSerializeds": SeedSourceSerializeds,
	"Notes":             SeedNotes,
}

// SeedList seeds the models for the testdb
func SeedList(list map[string]bool) error {
	isWhiteList, isBlacklist := true, true
	for k, v := range list {
		if v {
			isBlacklist = false
		} else {
			isWhiteList = false
			continue
		}
		seedFunc, exists := seedMap[k]
		if !exists {
			return fmt.Errorf("seedFunc for '%v' doesn't exist", k)
		}
		if err := seedFunc(); err != nil {
			return err
		}
	}
	for k, seedFunc := range seedMap {
		if _, exists := list[k]; !(isBlacklist && isWhiteList) &&
			(isBlacklist && exists || isWhiteList && !exists) {
			continue
		}
		if err := seedFunc(); err != nil {
			return err
		}
	}
	return nil
}

// TermsSeedFilename is the filename of the testdb models
const TermsSeedFilename = "TermsSeed.json"

// Terms are testdb models for Terms
func Terms() ([]db.Term, error) {
	var terms []db.Term
	if err := unmarshall(TermsSeedFilename, &terms); err != nil {
		return nil, err
	}
	return terms, nil
}

// TermsMust are testdb models for Terms, fails if there is an error
func TermsMust() []db.Term {
	terms, err := Terms()
	if err != nil {
		fmt.Println("TermsMust failed")
		os.Exit(-1)
	}
	return terms
}

// SeedTerms seeds the Terms testdb models
func SeedTerms() error {
	terms, err := Terms()
	if err != nil {
		return err
	}
	queries := db.Qs()
	for _, term := range terms {
		if _, err := queries.TermCreate(context.Background(), term.CreateParams()); err != nil {
			return err
		}
	}
	return nil
}

// SourceSerializedsSeedFilename is the filename of the testdb models
const SourceSerializedsSeedFilename = "SourceSerializedsSeed.json"

// SourceSerializeds are testdb models for SourceSerializeds
func SourceSerializeds() ([]db.SourceSerialized, error) {
	var sourceSerializeds []db.SourceSerialized
	if err := unmarshall(SourceSerializedsSeedFilename, &sourceSerializeds); err != nil {
		return nil, err
	}
	return sourceSerializeds, nil
}

// SourceSerializedsMust are testdb models for SourceSerializeds, fails if there is an error
func SourceSerializedsMust() []db.SourceSerialized {
	sourceSerializeds, err := SourceSerializeds()
	if err != nil {
		fmt.Println("SourceSerializedsMust failed")
		os.Exit(-1)
	}
	return sourceSerializeds
}

// SeedSourceSerializeds seeds the SourceSerializeds testdb models
func SeedSourceSerializeds() error {
	sourceSerializeds, err := SourceSerializeds()
	if err != nil {
		return err
	}
	queries := db.Qs()
	for _, sourceSerialized := range sourceSerializeds {
		if _, err := queries.SourceCreate(context.Background(), sourceSerialized.CreateParams()); err != nil {
			return err
		}
	}
	return nil
}

// NotesSeedFilename is the filename of the testdb models
const NotesSeedFilename = "NotesSeed.json"

// Notes are testdb models for Notes
func Notes() ([]db.Note, error) {
	var notes []db.Note
	if err := unmarshall(NotesSeedFilename, &notes); err != nil {
		return nil, err
	}
	return notes, nil
}

// NotesMust are testdb models for Notes, fails if there is an error
func NotesMust() []db.Note {
	notes, err := Notes()
	if err != nil {
		fmt.Println("NotesMust failed")
		os.Exit(-1)
	}
	return notes
}

// SeedNotes seeds the Notes testdb models
func SeedNotes() error {
	notes, err := Notes()
	if err != nil {
		return err
	}
	queries := db.Qs()
	for _, note := range notes {
		if _, err := queries.NoteCreate(context.Background(), note.CreateParams()); err != nil {
			return err
		}
	}
	return nil
}

func unmarshall(filename string, models any) error {
	bytes, err := os.ReadFile(path.Join(callerPath, "modeldata", filename))
	if err != nil {
		return err
	}
	return json.Unmarshal(bytes, models)
}
