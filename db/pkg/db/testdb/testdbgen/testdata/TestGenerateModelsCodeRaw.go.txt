// Code generated by testdb.GenerateModelsCode(). DO NOT EDIT.
//
// Package models contains the models used by testdb
package models

import (
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"path"
	"runtime"

	"github.com/s12chung/text2anki/db/pkg/db"
	"github.com/s12chung/text2anki/pkg/util/logg"
)

var callerPath string

func init() {
	_, callerFilePath, _, ok := runtime.Caller(0)
	if !ok {
		slog.Error("runtime.Caller not ok for models package")
		os.Exit(-1)
	}
	callerPath = path.Dir(callerFilePath)
}

var seedMap = map[string]func(tx db.Tx) error{
	"Terms":             SeedTerms,
	"SourceStructureds": SeedSourceStructureds,
	"Notes":             SeedNotes,
}

// SeedList seeds the models for the testdb
func SeedList(tx db.Tx, list map[string]bool) error {
	isWhiteList, isBlacklist := true, true
	for k, v := range list {
		if v {
			isBlacklist = false
		} else {
			isWhiteList = false
			continue
		}
		seedFunc, exists := seedMap[k]
		if !exists {
			return fmt.Errorf("seedFunc for '%v' doesn't exist", k)
		}
		if err := seedFunc(tx); err != nil {
			return err
		}
	}
	for k, seedFunc := range seedMap {
		if _, exists := list[k]; !(isBlacklist && isWhiteList) &&
			(isBlacklist && exists || isWhiteList && !exists) {
			continue
		}
		if err := seedFunc(tx); err != nil {
			return err
		}
	}
	return nil
}

// TermsSeedFilename is the filename of the testdb models
const TermsSeedFilename = "TermsSeed.json"

// Terms are testdb models for Terms
func Terms() ([]db.Term, error) {
	var terms []db.Term
	if err := unmarshall(TermsSeedFilename, &terms); err != nil {
		return nil, err
	}
	return terms, nil
}

// TermsMust are testdb models for Terms, fails if there is an error
func TermsMust() []db.Term {
	terms, err := Terms()
	if err != nil {
		slog.Error("TermsMust failed", logg.Err(err))
		os.Exit(-1)
	}
	return terms
}

// SeedTerms seeds the Terms testdb models
func SeedTerms(tx db.Tx) error {
	terms, err := Terms()
	if err != nil {
		return err
	}
	qs := db.New(tx)
	for _, term := range terms {
		if _, err := qs.TermCreate(tx.Ctx(), term.CreateParams()); err != nil {
			return err
		}
	}
	return nil
}

// SourceStructuredsSeedFilename is the filename of the testdb models
const SourceStructuredsSeedFilename = "SourceStructuredsSeed.json"

// SourceStructureds are testdb models for SourceStructureds
func SourceStructureds() ([]db.SourceStructured, error) {
	var sourceStructureds []db.SourceStructured
	if err := unmarshall(SourceStructuredsSeedFilename, &sourceStructureds); err != nil {
		return nil, err
	}
	return sourceStructureds, nil
}

// SourceStructuredsMust are testdb models for SourceStructureds, fails if there is an error
func SourceStructuredsMust() []db.SourceStructured {
	sourceStructureds, err := SourceStructureds()
	if err != nil {
		slog.Error("SourceStructuredsMust failed", logg.Err(err))
		os.Exit(-1)
	}
	return sourceStructureds
}

// SeedSourceStructureds seeds the SourceStructureds testdb models
func SeedSourceStructureds(tx db.Tx) error {
	sourceStructureds, err := SourceStructureds()
	if err != nil {
		return err
	}
	qs := db.New(tx)
	for _, sourceStructured := range sourceStructureds {
		if _, err := qs.SourceCreate(tx.Ctx(), sourceStructured.ToSourceCreateParams()); err != nil {
			return err
		}
	}
	return nil
}

// NotesSeedFilename is the filename of the testdb models
const NotesSeedFilename = "NotesSeed.json"

// Notes are testdb models for Notes
func Notes() ([]db.Note, error) {
	var notes []db.Note
	if err := unmarshall(NotesSeedFilename, &notes); err != nil {
		return nil, err
	}
	return notes, nil
}

// NotesMust are testdb models for Notes, fails if there is an error
func NotesMust() []db.Note {
	notes, err := Notes()
	if err != nil {
		slog.Error("NotesMust failed", logg.Err(err))
		os.Exit(-1)
	}
	return notes
}

// SeedNotes seeds the Notes testdb models
func SeedNotes(tx db.Tx) error {
	notes, err := Notes()
	if err != nil {
		return err
	}
	qs := db.New(tx)
	for _, note := range notes {
		if _, err := qs.NoteCreate(tx.Ctx(), note.CreateParams()); err != nil {
			return err
		}
	}
	return nil
}

func unmarshall(filename string, models any) error {
	bytes, err := os.ReadFile(path.Join(callerPath, "modeldata", filename))
	if err != nil {
		return err
	}
	return json.Unmarshal(bytes, models)
}
